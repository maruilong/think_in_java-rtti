在对Class的比较中 使用==和equals()的结果是一样的
instancof和isInstance()生成的结果是一样的
但是这两个的结果不一样,因为==主要表现的是你是不是这个类的确定类型 而instancof是问你是不是这个类 或者这个类的派生类

人们想在运行时获得类的信息的另一个动机便是希望提供在跨网络的远程平台上创建和运行对象的能力这被称为远程调用(RMI)他允许
一个java程序将对象分布到多台机器上,需要这种分部能力是有原因的
1:你可能在执行一项需进行大量计算的任务,为了提高运算速度,想将计算划分为许多小的计算单元,分部到空闲的机器上运行
2:你可能希望将处理特额定类型任务的代码置于特定的机器上

RTTI和反射的区别是
对于RTTI来说:编译器在编译时打开和检查.class文件我们可以用普通方式调用对象的所有方法
对于反射机制来说 .class文件在编译时是不可获取的 所以是在运行时打开和检查.class文件

反射在java中主要是支持例如对象序列化和javaBean这类特性的

代理:代理是一个基本的设计模式,他是你为了提供额外的或不同的操作,而插入的用来替代实际对象的对象这些操作通常设计与实际对象的通信
因此代理通常充当这中间人的角色

使用jdk动态代理
    public static Object newProxyInstance(ClassLoader loader,
                                          Class<?>[] interfaces,
                                          InvocationHandler h)
1:类加载器,你可以从已经被加载的类中获得
2:被代理的类所实现的接口(被代理的类必须实现接口)
3:InvationHandler接口的一个实现

在项目中,可以使用动态代理来实现对于事务的管理,可以在其执行失败时回滚成时提交,提高了代码的复用性

空对象设计模式:在检测null对象的时候,返回实际存在但是并不真实的值,通过这种方式,就可以假设所有代码都是有效的,而不用去重复的检查每个对象是否为null
可以在用到对象的时候不用进行重复的NULL测试 可以假设对象全都是有效的




